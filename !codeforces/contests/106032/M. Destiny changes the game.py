import sys
input = sys.stdin.readline        # ใช้ fast I/O: อ่านทีละบรรทัดจาก buffer เร็วกว่า input() ปกติ (ลด TLE จาก I/O ได้เยอะ)

t = int(input())                  # จำนวน test cases
for _ in range(t):                # วนทำทีละเทส
    q = int(input())              # จำนวน operations ในเทสนี้

    person = ( [0] * 26, [0] * 26 )  # person[0] = นับตัวอักษรของ Alice, person[1] = ของ Bob (ดัชนี 0..25 = 'a'..'z')
    person[0][0] += 1             # ทั้งคู่เริ่มด้วย "a" 1 ตัว → เพิ่มนับ 'a' ให้ Alice
    person[1][0] += 1             # เพิ่มนับ 'a' ให้ Bob

    s_len = [1, 1]                # ความยาวสตริงหลังเรียง (จริง ๆ คือความยาวรวม) ของ Alice/Bob (เริ่ม 1 เพราะ "a")

    for __ in range(q):           # ประมวลผลแต่ละ operation
        op, x, k = input().split()  # อ่านสามส่วน: op (1=Alice, 2=Bob), สตริง x, จำนวนครั้ง k
        op = int(op)-1            # แปลงเป็น 0/1 เพื่อใช้เป็นดัชนี (0=Alice, 1=Bob)
        k = int(k)                # k เป็นจำนวนเต็ม

        # อัปเดตการนับตัวอักษร: ต่อ x จำนวน k ครั้ง
        # ทำโดย "บวกทีเดียว" ต่ออักขระแต่ละตัวใน x ด้วยค่า k (ไม่ต่อสตริงจริง → ประหยัดเวลา/หน่วยความจำ)
        for c in x:
            person[op][ord(c)-ord('a')] += k   # เพิ่มตัวอักษร c ให้คนที่ op ถืออยู่ ด้วยจำนวน k
            s_len[op] += k                      # ความยาวรวมของฝั่งนี้เพิ่มขึ้น k ต่ออักขระ 1 ตัว → รวมแล้วได้ |x|*k

        rem_len = [s_len[0], s_len[1]]         # คัดลอกความยาวคงเหลือ (เอาไว้ใช้ตัดสินเคส prefix: สั้นกว่าเล็กกว่า)

        # เปรียบเทียบสตริงที่ "เรียงจาก a→z" โดยไม่ต้อง sort จริง:
        # เดินตั้งแต่ 'a'(i=0) ไปจน 'z'(i=25) แล้วตัดออกส่วนที่เท่ากัน (cut=min) ไปเรื่อย ๆ
        # จุดแรกที่จำนวนตัวอักษรต่างกัน จะชี้ผู้ชนะตามกฎ lexicographic
        for i in range(26):
            a = person[0][i]                  # จำนวนตัวอักษรตัวที่ i ของ Alice (หลังรวมทุก op แล้ว)
            b = person[1][i]                  # ของ Bob

            cut = min(a, b)                   # จำนวนที่ "จับคู่เท่ากัน" ได้ ณ ตัวอักษรนี้ (เทียบเหมือนหักคู่ออก)
            rem_len[0] -= cut                 # หักออกจากความยาวคงเหลือของ Alice
            rem_len[1] -= cut                 # หักออกจากความยาวคงเหลือของ Bob

            rem_a, rem_b = rem_len[0], rem_len[1]  # ย่อให้อ่านง่าย

            # ตรรกะชี้ขาด:
            # 1) ถ้า a < b  (Bob มีตัวอักษรนี้มากกว่า):
            #    - ถ้า Alice ไม่เหลือตัวอักษรเลย (rem_a==0) แต่ Bob ยังเหลือ (rem_b>0) → Alice เป็น prefix → "Alice" ชนะ (สั้นกว่า)
            #    - ถ้า Alice ยังเหลืออักษรอื่น (rem_a>0) → ตัวถัดไปของ Alice จะ > i ขณะที่ Bob ยังมี i อยู่ → Bob เล็กกว่า → "Bob"
            # 2) ถ้า a > b  (Alice มีมากกว่า) ⇒ กรณีสมมาตรกับข้อ 1) → ส่วนใหญ่จะเป็น "Alice"
            # โค้ดด้านล่างรวมเคสเหล่านี้ให้สั้น
            if (a < b and rem_a == 0 and rem_b > 0) or (a > b and rem_b > 0):
                print("Alice")                 # เคสที่ Alice เล็กกว่า (prefix หรือมีตัวอักษรที่เล็กกว่าฝั่ง Bob ในตำแหน่งแตกต่างแรก)
                break

            elif (b < a and rem_b == 0 and rem_a > 0) or (b > a and rem_a > 0):
                print("Bob")                   # เคสที่ Bob เล็กกว่า
                break

        else:
            # for-else: มาที่ else ได้ แปลว่า "ไม่ break เลย" ในลูป 26 ตัวอักษร
            # หมายถึง นับตัวอักษรทุกตัวเท่ากันหมด → สตริงหลังเรียงเหมือนกัน → "Tie"
            print("Tie")
